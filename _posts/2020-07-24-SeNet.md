# Squeeze and Excitation Networks Explained with PyTorch Implementation

1. TOC 
{:toc}

## Introduction 
In this blog post, we will be looking at the [Squeeze-and-Excitation](https://arxiv.org/abs/1709.01507) networks. We will refer to the [research paper by Hu et al](https://arxiv.org/abs/1709.01507) and first understand what **Squeeze-and-Excitation** networks are  before implementing the novel architecture in PyTorch with very few modifications to the popular `ResNet` architecture.

First, we develop an intuition for what SE-Nets are and the novel idea behind their success. Next, we will look at the **Squeeze** and **Excitation** operations in a little more detail. Finally, we implement the **Squeeze-and-Excitation** networks in PyTorch with very minor updates to the **Basic Block** for [ResNet](https://arxiv.org/abs/1512.03385).

## Intuition behind Squeeze-and-Excitation Networks
So, what's new in the Squeeze-and-Excitation networks? How are they different from the ResNet architecture? 

Let's consider an RGB image as an input. Then the convolution operation with a 3x3 kernel on the input image can be visualised as below:

![](/images/cnn.gif "fig-1: Convolution operation on RGB image; src: https://towardsdatascience.com/intuitively-understanding-convolutions-for-deep-learning-1f6f42faee1")

A feature map is generated per-channel (RGB) and then summed together to form one channel or the final output of the convolution operation. 

![](/images/output.gif "fig-2: Convolution output; src: https://towardsdatascience.com/intuitively-understanding-convolutions-for-deep-learning-1f6f42faee1")

The important point to note is that in a standard Convolution operation **each of the channels get equal weights**. 

**Main Idea behind Se-Nets**:

> It is possible that one of the channels might have more relevant information than the others. So, instead of giving each channel equal weights, it might be beneficial if more attention is paid to some channels and less attention is paid to the others. 

![](/images/senet_block.png "fig-3: Squeeze-and-Excitation block")

This main idea can be further explained using the **Squeeze-and-Excitation block** image above from the paper. First, a feature transformation (such as a convolution operation) is performed on the input image `X` to get features `U`. Next, we perform a **squeeze** operation to get a single value for each channel. After, we perform an **excitation** operation on the output of the **squeeze** operation to get per-channel weights. Finally, the output of the **Squeeze-and-Excitation block** is the weighted sum per-channel. In the image above, notice how each channel has a distinct colour where this colour corresponds to the channel weights. 

From the paper: 
> The role this operation performs at different depths differs throughout the network. In earlier layers, it excites informative features in a class-agnostic manner, strengthening the shared low-level representations. In later layers, the SE blocks become increasingly specialised, and respond to different inputs in a highly class-specific manner. As a consequence, the benefits of the feature recalibration performed by SE blocks can be accumulated through the network.

Now, we will look at the **Squeeze** and **Excitation** operations in a little more detail. 

## Squeeze: Global Information Embedding

The main purpose of the Squeeze operation is to extract global information from each of the channels of an image. Since, convolution is a local operation (that is, at a particular time, it is only able to see a part of the image), it might be beneficial to also extract information outside the receptive field of the convolution filter. 

The **Squeeze** operation is meant to do exactly that and the authors keep it as simple as possible. 

The authors perform a Global Average Pooling operation to reduce the `C x H x W` image to `C x 1 x 1` to get a global statistic for each channel. 

Formally, the Global Average Pooling or the Squeeze operation can be represented as: 

![](/images/squeeze.png "eq-1: Global Average Pooling")

In other words, all we are doing is taking the mean of each channel across `H x W` spatial dimensions. 

## Excitation: Adaptive Recalibration 

Now that we have a vector of length `C` from the [Squeeze]() operation, the next step is to generate a set of weights for each channel. This is done with the help of **Excitation** operation explained in this section. 

Formally, the excitation operation can be represented by:

![](/images/gating_operation.png "eq-2: Excitation")

where:	
- `δ` refers to ReLU operation	
- `σ` refers to Sigmoid operation 	
- `W1` and `W2` are two fully-connected layers	
- `z` is the output from the Squeeze block

The two FC layers form a bottleneck architecture, that is, the first `W1` layer is used for dimensionality reduction by a ratio `r` and the second `W2` layer is a dimensionality increasing layer returning to the channel dimension of `U`.	

Since, the Sigmoid layer would return numbers between 0 and 1, these are the channel weights and the final output of the block can be respresented as:	

![](/images/senet_output.png "fig4: SeNet output")


## Squeeze and Excitation in PyTorch

```python
class SE_Block(nn.Module):
    "credits: https://github.com/moskomule/senet.pytorch/blob/master/senet/se_module.py#L4"
    def __init__(self, c, r=16):
        super().__init__()
        self.squeeze = nn.AdaptiveAvgPool2d(1)
        self.excitation = nn.Sequential(
            nn.Linear(c, c // r, bias=False),
            nn.ReLU(inplace=True),
            nn.Linear(c // r, c, bias=False),
            nn.Sigmoid()
        )

    def forward(self, x):
        bs, c, _, _ = x.shape
        y = self.squeeze(x).view(bs, c)
        y = self.excitation(y).view(bs, c, 1, 1)
        return x * y.expand_as(x)
```

As mentioned the **Squeeze** operation is a global Average Pooling operation and in PyTorch this can be represented as `nn.AdaptiveAvgPool2d(1)` where 1, represents the output size. 

Next, the **Excitation** network is a bottle neck architecture with two FC layers, first to reduce the dimensions and second to increase the dimensions back to original. We reduce the dimensions by a reduction ratio `r=16`. This is as simple as creating a `nn.Sequential` with two FC layers, with a `nn.ReLU()` in between and followed by a `nn.Sigmoid()`.

The outputs of the **Excitation** operation are the channel weights which are then multiplied element-wise to input feature `X` to get the final output of the `SE_Block`.